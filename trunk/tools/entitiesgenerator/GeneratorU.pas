unit GeneratorU;

interface

uses
  System.Classes, Data.DB, Generics.Collections, SysUtils, ioutils;

type
  TGenerator = class
  private
    FOutput: TStringStream;
    FTables: TStrings;
    FDSCallback: TFunc<String, TDataSet>;
    FCurrentDS: TDataSet;
    procedure EmitGettersSetters;
  protected
    procedure EmitProperty(F: TField);
    procedure EmitSetter(F: TField);
    procedure EmitField(F: TField);
    procedure EmitFields;
    procedure EmitProperties;
    procedure EmitClass(TableName: String);
    procedure EmitClassEnd;
    procedure EmitSettersBody(const AClassName: String);
    procedure EmitSetterBody(const AClassName: String; F: TField);
    function GetDelphiType(FT: TFieldType): String;
    function GetProperCase(const Value: String): String;
  public
    constructor Create(ATables: TStrings;
      GetFieldsCallback: TFunc<String, TDataSet>); virtual;
    destructor Destroy; override;
    procedure Execute;
    property Output: TStringStream read FOutput;
  end;

implementation

{ TGenerator }

uses cOMMONSu;

constructor TGenerator.Create(ATables: TStrings;
  GetFieldsCallback: TFunc<String, TDataSet>);
begin
  inherited Create;
  FTables := ATables;
  FOutput := TStringStream.Create;
  FDSCallback := GetFieldsCallback;
end;

destructor TGenerator.Destroy;
begin
  FOutput.Free;
  inherited;
end;

procedure TGenerator.Execute;
var
  i: Integer;
  table: String;
  TheClassName: String;
begin
  FOutput.WriteString('{ ================================================ }' +
    sLineBreak);
  FOutput.WriteString('{ Proudly generated by the DORM entities generator }' +
    sLineBreak);
  FOutput.WriteString('{ generated on ' + DateTimeToStr(now) + '                 }' +
    sLineBreak);
  FOutput.WriteString('{ DO NOT CHANGE THIS FILE!!!                       }' +
    sLineBreak);
  FOutput.WriteString('{ ================================================ }' +
    sLineBreak);

  FOutput.WriteString('unit ' + tpath.GetFileNameWithoutExtension
    (TConfig.OUTPUTFILENAME) + ';' + sLineBreak + sLineBreak);
  FOutput.WriteString('interface' + sLineBreak + sLineBreak);
  FOutput.WriteString('type' + sLineBreak);
  for table in FTables do
  begin
    FCurrentDS := FDSCallback(table);
    EmitClass(table);
    FOutput.WriteString('  protected' + sLineBreak);
    EmitFields;
    EmitGettersSetters;
    FOutput.WriteString('  public' + sLineBreak);
    EmitProperties;
    EmitClassEnd;
  end;

  FOutput.WriteString('implementation' + sLineBreak + sLineBreak);
  for table in FTables do
  begin
    FCurrentDS := FDSCallback(table);
    TheClassName := table;
    TheClassName := 'T' + GetProperCase(TheClassName);
    EmitSettersBody(TheClassName);
  end;
  FOutput.WriteString('end.');
end;

function TGenerator.GetDelphiType(FT: TFieldType): String;
begin
  case FT of
    ftString:
      Result := 'String';
    ftSmallint, ftInteger, ftWord, ftLongWord, ftShortint:
      Result := 'Integer';
    ftByte:
      Result := 'Byte';
    ftLargeint:
      Result := 'Int64';
    ftBoolean:
      Result := 'Boolean';
    ftFloat, ftSingle, ftExtended:
      Result := 'Double';
    ftCurrency, ftBCD:
      Result := 'Currency';
    ftDate:
      Result := 'TDate';
    ftTime:
      Result := 'TTime';
    ftDateTime:
      Result := 'TDateTime';
    ftTimeStamp:
      Result := 'TDateTime {timestamp}';
    ftAutoInc:
      Result := 'Integer {autoincrement}';
    ftBlob, ftMemo, ftGraphic, ftFmtMemo, ftWideMemo, ftStream:
      Result := 'TStream';
    ftFixedChar:
      Result := 'String {fixedchar}';
    ftWideString:
      Result := 'String';
  else
    Result := '<UNSUPPORTED TYPE>';
    // + TEnum.GetName<TFieldType>(FT) + '>';
  end;
end;

function TGenerator.GetProperCase(const Value: String): String;
var
  Pieces: TArray<String>;
  s: String;
begin
  if not TConfig.CAPITALIZE then
    Exit(Value);

  Result := '';
  if Value.Length <= 2 then
    Exit(Value.ToUpper);

  Pieces := Value.ToLower.Split(['_']);
  for s in Pieces do
  begin
    if s = 'id' then
      Result := Result + 'ID'
    else
      Result := Result + uppercase(s.Chars[0]) + s.Substring(1);
  end;
end;

procedure TGenerator.EmitClass(TableName: String);
begin
  FOutput.WriteString('  [MapperJSONNaming(JSONNameLowerCase)]' + sLineBreak);
  if trim(TableName) <> '' then
  begin
    FOutput.WriteString(Format('  [Entity(''%s'')]', [TableName]) + sLineBreak);
  end;

  FOutput.WriteString('  T' + GetProperCase(TableName) + ' = class(' +
    TConfig.PARENTCLASS + ')' + sLineBreak);

  // if trim(Edit1.Text) = '' then
  // raise Exception.Create('Invalid class name');
  // if (Edit3.Text <> '') and (LowerCase(Edit3.Text) <> 'inheritedclass') then
  // FOutput.WriteString(Edit1.Text + ' = class(TBaseV)' + sLineBreak)
  // else
  // FOutput.WriteString(Edit1.Text + ' = class' + sLineBreak);

end;

procedure TGenerator.EmitClassEnd;
begin
  FOutput.WriteString('  end;' + sLineBreak + sLineBreak);
end;

procedure TGenerator.EmitField(F: TField);
var
  PropName: string;
begin
  if (not TConfig.PROPERTYID) and (LowerCase(F.FieldName) = 'id') then
    Exit;
  if (not TConfig.PROPERTYOBJVERSION) and (LowerCase(F.FieldName) = 'objversion')
  then
    Exit;

  PropName := GetProperCase(F.FieldName);
  FOutput.WriteString('    F' + PropName + ': ' + GetDelphiType(F.DataType) +
    ';' + sLineBreak);
end;

procedure TGenerator.EmitFields;
var
  i: Integer;
begin
  for i := 0 to FCurrentDS.Fields.Count - 1 do
  begin
    EmitField(FCurrentDS.Fields[i]);
  end;
end;

procedure TGenerator.EmitProperty(F: TField);
var
  PropName: string;
begin
  // if NoPropertyCase.Checked then
  // FOutput.WriteString(Format('  [Column(''%s'')]', [F.FieldName]) + sLineBreak
  // + '  property ' + F.FieldName + ': ' + GetDelphiType(F.DataType) + ';' +
  // sLineBreak)
  // else
  if (not TConfig.PROPERTYID) and (LowerCase(F.FieldName) = 'id') then
    Exit;
  if (not TConfig.PROPERTYOBJVERSION) and (LowerCase(F.FieldName) = 'objversion')
  then
    Exit;

  PropName := GetProperCase(F.FieldName);

  if TConfig.COLUMNATTRIBUTE then
    FOutput.WriteString(Format('    [Column(''%s'')]' + sLineBreak,
      [F.FieldName]));

  FOutput.WriteString('    property ' + PropName + ': ' +
    GetDelphiType(F.DataType) + ' read F' + PropName + ' write Set' + PropName +
    ';' + sLineBreak);
end;

procedure TGenerator.EmitSetter(F: TField);
var
  PropName: string;
begin
  if (not TConfig.PROPERTYID) and (LowerCase(F.FieldName) = 'id') then
    Exit;

  if (not TConfig.PROPERTYOBJVERSION) and (LowerCase(F.FieldName) = 'objversion')
  then
    Exit;

  PropName := GetProperCase(F.FieldName);
  FOutput.WriteString('    procedure Set' + PropName + '(const Value: ' +
    GetDelphiType(F.DataType) + ');' + sLineBreak);
end;

procedure TGenerator.EmitSetterBody(const AClassName: String; F: TField);
var
  PropName: string;
begin
  if (not TConfig.PROPERTYID) and (LowerCase(F.FieldName) = 'id') then
    Exit;
  if (not TConfig.PROPERTYOBJVERSION) and (LowerCase(F.FieldName) = 'objversion')
  then
    Exit;

  PropName := GetProperCase(F.FieldName);
  FOutput.WriteString('procedure ' + AClassName + '.Set' + PropName +
    '(const Value: ' + GetDelphiType(F.DataType) + ');' + sLineBreak);
  FOutput.WriteString('begin' + sLineBreak + '  F' + PropName + ' := Value;' +
    sLineBreak + 'end;' + sLineBreak + sLineBreak);

end;

procedure TGenerator.EmitProperties;
var
  i: Integer;
begin
  for i := 0 to FCurrentDS.Fields.Count - 1 do
  begin
    EmitProperty((FCurrentDS.Fields[i]))
  end;
end;

procedure TGenerator.EmitGettersSetters;
var
  i: Integer;
begin
  for i := 0 to FCurrentDS.Fields.Count - 1 do
  begin
    EmitSetter((FCurrentDS.Fields[i]))
  end;
end;

procedure TGenerator.EmitSettersBody(const AClassName: String);
var
  i: Integer;
begin
  for i := 0 to FCurrentDS.Fields.Count - 1 do
  begin
    EmitSetterBody(AClassName, FCurrentDS.Fields[i]);
  end;
end;

end.
