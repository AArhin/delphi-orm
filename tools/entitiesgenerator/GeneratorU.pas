unit GeneratorU;

interface

uses
  System.Classes, Data.DB, Generics.Collections, SysUtils, ioutils;

type
  TGenerator = class
  private
    FOutput: TStringStream;
    FTables: TStrings;
    FDSCallback: TFunc<String, TDataSet>;
    FCurrentDS: TDataSet;
    procedure EmitGettersSetters;
  protected
    procedure EmitInterfaceUses;
    procedure EmitProperty(F: TField);
    procedure EmitSetter(F: TField);
    procedure EmitField(F: TField);
    procedure EmitFields;
    procedure EmitProperties(TableName: String);
    procedure EmitClass(TableName: String);
    procedure EmitClassEnd;
    procedure EmitSettersBody(const AClassName, ATableName: String);
    procedure EmitSetterBody(const AClassName: String; F: TField;
      ATableName: String);
    function GetDelphiType(FT: TFieldType): String;
    function GetProperCase(const Value: String): String;
  public
    constructor Create(ATables: TStrings;
      GetFieldsCallback: TFunc<String, TDataSet>); virtual;
    destructor Destroy; override;
    procedure Execute;
    property Output: TStringStream read FOutput;
  end;

implementation

{ TGenerator }

uses CommonsU, System.StrUtils;

constructor TGenerator.Create(ATables: TStrings;
  GetFieldsCallback: TFunc<String, TDataSet>);
begin
  inherited Create;
  FTables := ATables;
  FOutput := TStringStream.Create;
  FDSCallback := GetFieldsCallback;
end;

destructor TGenerator.Destroy;
begin
  FOutput.Free;
  inherited;
end;

procedure TGenerator.Execute;
var
  table: String;
  TheClassName: String;
begin
  FOutput.WriteString('{ ================================================ }' +
    sLineBreak);
  FOutput.WriteString('{ Proudly generated by the DORM entities generator }' +
    sLineBreak);
  FOutput.WriteString('{ generated on ' + DateTimeToStr(now) +
    '                 }' + sLineBreak);
  FOutput.WriteString('{ DO NOT CHANGE THIS FILE!!!                       }' +
    sLineBreak);
  FOutput.WriteString('{ ================================================ }' +
    sLineBreak);

  FOutput.WriteString('unit ' + tpath.GetFileNameWithoutExtension
    (TConfig.OUTPUTFILENAME) + ';' + sLineBreak + sLineBreak);
  FOutput.WriteString('interface' + sLineBreak + sLineBreak);
  EmitInterfaceUses;
  FOutput.WriteString('type' + sLineBreak);
  for table in FTables do
  begin
    FCurrentDS := FDSCallback(table);
    EmitClass(table);
    FOutput.WriteString('  protected' + sLineBreak);
    EmitFields;
    EmitGettersSetters;
    FOutput.WriteString('  public' + sLineBreak);
    EmitProperties(table);
    EmitClassEnd;
  end;

  FOutput.WriteString('implementation' + sLineBreak + sLineBreak);
  for table in FTables do
  begin
    FCurrentDS := FDSCallback(table);
    TheClassName := table;
    TheClassName := 'T' + TConfig.CLASSSUFFIX + GetProperCase(TheClassName);
    EmitSettersBody(TheClassName, table);
  end;
  FOutput.WriteString('end.');
end;

function TGenerator.GetDelphiType(FT: TFieldType): String;
begin
  case FT of
    ftString:
      Result := 'String';
    ftSmallint, ftInteger, ftWord, ftLongWord, ftShortint:
      Result := 'Integer';
    ftByte:
      Result := 'Byte';
    ftLargeint:
      Result := 'Int64';
    ftBoolean:
      Result := 'Boolean';
    ftFloat, ftSingle, ftExtended:
      Result := 'Double';
    ftCurrency, ftBCD:
      Result := 'Currency';
    ftDate:
      Result := 'TDate';
    ftTime:
      Result := 'TTime';
    ftDateTime:
      Result := 'TDateTime';
    ftTimeStamp:
      Result := 'TDateTime {timestamp}';
    ftAutoInc:
      Result := 'Integer {autoincrement}';
    ftBlob, ftMemo, ftGraphic, ftFmtMemo, ftWideMemo, ftStream:
      Result := 'TStream';
    ftFixedChar:
      Result := 'String {fixedchar}';
    ftWideString:
      Result := 'String';
  else
    Result := '<UNSUPPORTED TYPE>';
    // + TEnum.GetName<TFieldType>(FT) + '>';
  end;
end;

function TGenerator.GetProperCase(const Value: String): String;
var
  Pieces: TArray<String>;
  s: String;
begin
  if not TConfig.CAPITALIZE then
    Exit(Value);

  Result := '';
  if Value.Length <= 2 then
    Exit(Value.ToUpper);

  Pieces := Value.ToLower.Split(['_']);
  for s in Pieces do
  begin
    if s = 'id' then
      Result := Result + 'ID'
    else
      Result := Result + uppercase(s.Chars[0]) + s.Substring(1);
  end;
end;

procedure TGenerator.EmitClass(TableName: String);
begin
  {
    FOutput.WriteString('  [MapperJSONNaming(JSONNameLowerCase)]' + sLineBreak);
    if trim(TableName) <> '' then
    begin
    FOutput.WriteString(Format('  [Entity(''%s'')]', [TableName]) + sLineBreak);
    end;
  }
  FOutput.WriteString('  T' + TConfig.CLASSSUFFIX + GetProperCase(TableName) + ' = class(' +
    TConfig.PARENTCLASS + ')' + sLineBreak);

  // if trim(Edit1.Text) = '' then
  // raise Exception.Create('Invalid class name');
  // if (Edit3.Text <> '') and (LowerCase(Edit3.Text) <> 'inheritedclass') then
  // FOutput.WriteString(Edit1.Text + ' = class(TBaseV)' + sLineBreak)
  // else
  // FOutput.WriteString(Edit1.Text + ' = class' + sLineBreak);

end;

procedure TGenerator.EmitClassEnd;
begin
  FOutput.WriteString('  end;' + sLineBreak + sLineBreak);
end;

procedure TGenerator.EmitField(F: TField);
var
  PropName: string;
begin
  if (not TConfig.PROPERTYID) and (LowerCase(F.FieldName) = 'id') then
    Exit;
  if (not TConfig.PROPERTYOBJVERSION) and (LowerCase(F.FieldName) = 'objversion')
  then
    Exit;

  PropName := GetProperCase(F.FieldName);
  FOutput.WriteString('    F' + PropName + ': ' + GetDelphiType(F.DataType) +
    ';' + sLineBreak);
end;

procedure TGenerator.EmitFields;
var
  i: Integer;
  ExcludedFields: TArray<string>;
begin
  ExcludedFields := TConfig.EXCLUDEDCOLUMNS.Split([',']);
  for i := 0 to FCurrentDS.Fields.Count - 1 do
  begin
    if not MatchText(FCurrentDS.Fields[i].FieldName, ExcludedFields) then
      EmitField(FCurrentDS.Fields[i]);
  end;
end;

procedure TGenerator.EmitProperty(F: TField);
var
  PropName: string;
begin
  // if NoPropertyCase.Checked then
  // FOutput.WriteString(Format('  [Column(''%s'')]', [F.FieldName]) + sLineBreak
  // + '  property ' + F.FieldName + ': ' + GetDelphiType(F.DataType) + ';' +
  // sLineBreak)
  // else
  if (not TConfig.PROPERTYID) and (LowerCase(F.FieldName) = 'id') then
    Exit;
  if (not TConfig.PROPERTYOBJVERSION) and (LowerCase(F.FieldName) = 'objversion')
  then
    Exit;

  PropName := GetProperCase(F.FieldName);

  if TConfig.COLUMNATTRIBUTE then
    FOutput.WriteString(Format('    [Column(''%s'')]' + sLineBreak,
      [F.FieldName]));

  FOutput.WriteString('    property ' + PropName + ': ' +
    GetDelphiType(F.DataType) + ' read F' + PropName + ' write Set' + PropName +
    ';' + sLineBreak);
end;

procedure TGenerator.EmitSetter(F: TField);
var
  PropName: string;
begin
  if (not TConfig.PROPERTYID) and (LowerCase(F.FieldName) = 'id') then
    Exit;

  if (not TConfig.PROPERTYOBJVERSION) and (LowerCase(F.FieldName) = 'objversion')
  then
    Exit;

  PropName := GetProperCase(F.FieldName);
  FOutput.WriteString('    procedure Set' + PropName + '(const Value: ' +
    GetDelphiType(F.DataType) + ');' + sLineBreak);
end;

procedure TGenerator.EmitSetterBody(const AClassName: String; F: TField;
  ATableName: String);
var
  PropName: string;
  ExcludedFields, FieldsSerializeAsString: TArray<string>;
  FieldName: string;
begin
  if (not TConfig.PROPERTYID) and (LowerCase(F.FieldName) = 'id') then
    Exit;
  if (not TConfig.PROPERTYOBJVERSION) and (LowerCase(F.FieldName) = 'objversion')
  then
    Exit;

  FieldsSerializeAsString := TConfig.FieldsSerializeAsString.Split([',']);
  ExcludedFields := TConfig.EXCLUDEDCOLUMNS.Split([',']);
  if not MatchText(F.FieldName, ExcludedFields) then
  begin
    PropName := GetProperCase(F.FieldName);
    FOutput.WriteString('procedure ' + AClassName + '.Set' + PropName +
      '(const Value: ' + GetDelphiType(F.DataType) + ');' + sLineBreak);
    FieldName := ATableName + '.' + F.FieldName;
    if MatchText(FieldName, FieldsSerializeAsString) then
      FOutput.WriteString('begin' + sLineBreak + '  if Assigned(F' + PropName +
        ') then' + sLineBreak + '    F' + PropName + '.Free;' + sLineBreak + '  F' +
        PropName + ' := Value;' + sLineBreak + 'end;' + sLineBreak + sLineBreak)
    else
      FOutput.WriteString('begin' + sLineBreak + '  F' + PropName + ' := Value;'
        + sLineBreak + 'end;' + sLineBreak + sLineBreak);
  end;
end;

procedure TGenerator.EmitProperties(TableName: String);
var
  i: Integer;
  ExcludedFields, TablesColumnsNullable, FieldsSerializeAsString
    : TArray<string>;
  FieldName: string;
begin
  ExcludedFields := TConfig.EXCLUDEDCOLUMNS.Split([',']);
  TablesColumnsNullable := TConfig.TablesColumnsNullable.Split([',']);
  FieldsSerializeAsString := TConfig.FieldsSerializeAsString.Split([',']);
  for i := 0 to FCurrentDS.Fields.Count - 1 do
  begin
    if not MatchText(FCurrentDS.Fields[i].FieldName, ExcludedFields) then
    begin
      FieldName := TableName + '.' + FCurrentDS.Fields[i].FieldName;
      if MatchText(FieldName, TablesColumnsNullable) then
        FOutput.WriteString('    [Nullable]' + sLineBreak);
      if MatchText(FieldName, FieldsSerializeAsString) then
        FOutput.WriteString('    [MapperSerializeAsString(''utf-16'')]' +
          sLineBreak);
      EmitProperty((FCurrentDS.Fields[i]));
    end;
  end;
end;

procedure TGenerator.EmitGettersSetters;
var
  i: Integer;
  ExcludedFields: TArray<string>;
begin
  ExcludedFields := TConfig.EXCLUDEDCOLUMNS.Split([',']);
  for i := 0 to FCurrentDS.Fields.Count - 1 do
  begin
    if not MatchText(FCurrentDS.Fields[i].FieldName, ExcludedFields) then
      EmitSetter((FCurrentDS.Fields[i]))
  end;
end;

procedure TGenerator.EmitInterfaceUses;
begin
  if TConfig.INTERFACEUSES <> '' then
    FOutput.WriteString('uses ' + sLineBreak + '  ' + TConfig.INTERFACEUSES +
      ';' + sLineBreak + sLineBreak);
end;

procedure TGenerator.EmitSettersBody(const AClassName, ATableName: String);
var
  i: Integer;
begin
  for i := 0 to FCurrentDS.Fields.Count - 1 do
  begin
    EmitSetterBody(AClassName, FCurrentDS.Fields[i], ATableName);
  end;
end;

end.
